---
title: "658 - æ‰¾åˆ° K ä¸ªæœ€æŽ¥è¿‘çš„å…ƒç´ "
date: 2022-08-25T22:28:37+08:00
description: "8æœˆ25æ—¥ å‘¨å›› é›¨ðŸŒ§ æ¯æ—¥ä¸€é¢˜"
featured_image: "https://pic.danic.tech/blog/bg/bg-31.jpg"
tags: ["leetcode", "äºŒåˆ†", "å †", "æŽ’åº"]

---

# é¢˜

>   #### [658. æ‰¾åˆ° K ä¸ªæœ€æŽ¥è¿‘çš„å…ƒç´ ](https://leetcode.cn/problems/find-k-closest-elements/)
>
>   ç»™å®šä¸€ä¸ª **æŽ’åºå¥½** çš„æ•°ç»„ `arr` ï¼Œä¸¤ä¸ªæ•´æ•° `k` å’Œ `x` ï¼Œä»Žæ•°ç»„ä¸­æ‰¾åˆ°æœ€é è¿‘ `x`ï¼ˆä¸¤æ•°ä¹‹å·®æœ€å°ï¼‰çš„ `k` ä¸ªæ•°ã€‚è¿”å›žçš„ç»“æžœå¿…é¡»è¦æ˜¯æŒ‰å‡åºæŽ’å¥½çš„ã€‚
>
>   æ•´æ•° `a` æ¯”æ•´æ•° `b` æ›´æŽ¥è¿‘ `x` éœ€è¦æ»¡è¶³ï¼š
>
>   -   `|a - x| < |b - x|` æˆ–è€…
>   -   `|a - x| == |b - x|` ä¸” `a < b`
>
>    
>
>   **ç¤ºä¾‹ 1ï¼š**
>
>   ```
>   è¾“å…¥ï¼šarr = [1,2,3,4,5], k = 4, x = 3
>   è¾“å‡ºï¼š[1,2,3,4]
>   ```
>
>   **ç¤ºä¾‹ 2ï¼š**
>
>   ```
>   è¾“å…¥ï¼šarr = [1,2,3,4,5], k = 4, x = -1
>   è¾“å‡ºï¼š[1,2,3,4]
>   ```
>
>    
>
>   **æç¤ºï¼š**
>
>   -   `1 <= k <= arr.length`
>   -   `1 <= arr.length <= 104`
>   -   `arr` æŒ‰ **å‡åº** æŽ’åˆ—
>   -   `-104 <= arr[i], x <= 104`



# æž

é¢˜æ„æ˜¯æ‰¾æ•°ç»„ä¸­æœ€é è¿‘`x`çš„`k`ä¸ªæ•°ï¼Œå¹¶ä¸”åŽŸæ•°ç»„ä¹Ÿæ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆåŸºäºŽæ•°ç»„æœ‰åºçš„å‰æï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿæ‰¾åˆ°æœ€æŽ¥è¿‘`x`çš„æ•°`i`ï¼Œç„¶åŽä»Ž`i`å¼€å§‹å‘ä¸¤ä¾§æœç´¢ä¸Ž`x`ç»å¯¹å€¼æœ€å°çš„æ•°å­—åŠ å…¥ç­”æ¡ˆä¸­ï¼Œç›´è‡³æ·»åŠ `k`ä¸ªåŽç»“æŸã€‚



# è§£

### äºŒåˆ†è§£æ³•

```go
// äºŒåˆ†æœç´¢targetå³ä¾§çš„ä¸‹æ ‡
func bisectRight(arr []int, target int) int {
    l, r := 0, len(arr)
    for l < r {
        m := l + (r-l)>>1
        if arr[m] <= target {
            l = m+1
        } else {
            r = m
        }
    }
    return l
}

func findClosestElements(arr []int, k int, x int) []int {
  	// æ‰¾åˆ°å³è¾¹ç•Œlï¼Œä¸‹æ ‡låŠä¹‹å‰å°äºŽç­‰äºŽx
    l := bisectRight(arr, x) - 1
    // ä¸‹æ ‡råŠä¹‹åŽå¤§äºŽx
    r := l+1
    cnt := 0
    n := len(arr)
    for cnt < k {
        cnt++
        if l < 0 {
            r++
        } else if r >= n || (x-arr[l]) <= (arr[r]-x) {
            // æ­¤å¤„å¯ä»¥ä¸ç”¨ç»å¯¹å€¼ï¼Œå› ä¸ºlæ‰€åœ¨å¿…ç„¶å°äºŽç­‰äºŽxï¼Œræ‰€åœ¨å¿…ç„¶å¤§äºŽx
            l--
        } else {
            r++
        }
    }
    return arr[l+1:r]
}
```



### æŽ’åºè§£æ³•

ä½¿ç”¨ä¸€ç§ç¨³å®šæŽ’åºçš„ç®—æ³•ï¼Œä¿è¯æŒ‰ä¸Ž`x`çš„ç»å¯¹å€¼ä»Žå°åˆ°å¤§æŽ’åºåŽï¼Œç›¸å¯¹é¡ºåºä¾æ—§ä¸å˜ï¼Œç„¶åŽå–å‰kä¸ªé‡æ–°æŽ’åºå³å¯ã€‚

```go
// å½’å¹¶æŽ’åº
func MergeSort(arr []int, l, r int, less func(i, j int) bool) {
    if r-l <= 1 {
        return
    }
    m := l + (r-l)>>1
    MergeSort(arr, l, m, less)
    MergeSort(arr, m, r, less)
    Merge(arr, l, r, m, less)
}

func Merge(arr []int, l, r, m int, less func(i, j int) bool) {
    left := make([]int, m-l)
    right := make([]int, r-m)
    copy(left, arr[l:m])
    copy(right, arr[m:r])
    il, ir := 0, 0
    for i := l; i < r; i++ {
        if il >= len(left) {
            arr[i] = right[ir]
            ir++
        } else if ir >= len(right) || !less(right[ir], left[il]) {
            arr[i] = left[il]
            il++
        } else {
            arr[i] = right[ir]
            ir++
        }
    }
}

func abs(a, b int) int {
    if a > b {
        return a - b
    }
    return b - a
}

func findClosestElements(arr []int, k int, x int) []int {
    MergeSort(arr, 0, len(arr), func(i, j int) bool {
        return abs(i, x) < abs(j, x)
    })

    arr = arr[:k]
    sort.Ints(arr)
    return arr
}
```



### å¤§é¡¶å †è§£æ³•

```go
type Item struct {
	idx     int
	val     int
	realVal int
}

type Heap struct {
	arr  []Item
	less func(i, j int) bool
	swap func(i, j int)
}

func (h *Heap) Sink() {
	n := 0
	for {
		l := n*2 + 1
		if l >= len(h.arr) {
			break
		}
		j := l
		r := l + 1
		if r < len(h.arr) && h.less(r, l) {
			j = r
		}
		if h.less(n, j) {
			break
		}
		h.swap(n, j)
		n = j
	}
}

func (h *Heap) Swim() {
	n := len(h.arr) - 1
	for {
		p := (n - 1) / 2
		if n == 0 || h.less(p, n) {
			break
		}
		h.swap(p, n)
		n = p
	}
}

func (h *Heap) Pop() Item {
	v := h.arr[0]
	h.swap(0, len(h.arr)-1)
	h.arr = h.arr[:len(h.arr)-1]
	h.Sink()
	return v
}

func (h *Heap) Push(v Item) {
	h.arr = append(h.arr, v)
	h.Swim()
}

func abs(a, b int) int {
	if a > b {
		return a - b
	}
	return b - a
}

func findClosestElements(arr []int, k int, x int) []int {
	h := &Heap{arr: make([]Item, 0)}
	h.less = func(i, j int) bool {
		// å…ˆæŒ‰ç»å¯¹å€¼ä»Žå¤§åˆ°å°æŽ’åºï¼ŒåŽæŒ‰ç´¢å¼•ä»Žå¤§åˆ°å°æŽ’åº
		vi, vj := h.arr[i].val, h.arr[j].val
		ii, ij := h.arr[i].idx, h.arr[j].idx
		return vi > vj || vi == vj && ii > ij
	}
	h.swap = func(i, j int) {
		h.arr[i], h.arr[j] = h.arr[j], h.arr[i]
	}

	for i, v := range arr {
		// å°†å€¼æ”¾å…¥å¤§é¡¶å †
		h.Push(Item{i, abs(v, x), v})
		// å½“å¤§é¡¶å †çš„å¤§å°è¶…è¿‡kæ—¶ï¼Œè¡¨ç¤ºæ•°æ®æ¡ç›®æº¢å‡ºï¼Œå¯ä»¥æŠŠæœ€å¤§çš„ï¼ˆæœ€ä¸ç¬¦åˆæ¡ä»¶çš„ï¼‰å¼¹å‡º
		if len(h.arr) > k {
			h.Pop()
		}
	}
	ans := make([]int, k)
	for i := 0; i < k; i++ {
		ans[i] = h.Pop().realVal
	}

	// é‡æ–°æŽ’åº
	sort.Ints(ans)
	return ans
}
```

