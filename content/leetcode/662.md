---
title: "662 - 二叉树最大宽度"
date: 2022-08-27T23:09:28+08:00
description: "8月27日 周六 阴☁️ 每日一题"
featured_image: "https://pic.danic.tech/blog/bg/bg-33.jpg"
tags: ["leetcode", "树", "BFS", "DFS"]
---

# 题

>   #### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)
>
>   给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。
>
>   树的 **最大宽度** 是所有层中最大的 **宽度** 。
>
>   每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。
>
>   题目数据保证答案将会在 **32 位** 带符号整数范围内。
>
>   **示例 1：**
>
>   ![img](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg)
>
>   ```
>   输入：root = [1,3,2,5,null,null,9,6,null,7]
>   输出：7
>   解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
>   ```
>
>   **提示：**
>
>   -   树中节点的数目范围是 `[1, 3000]`
>   -   `-100 <= Node.val <= 100`



# 析

根据题意，需要找出给定树的最大宽度，因此需要扫描所有层，将每层第一个有值到最后一个有值的距离算出来，然后取最大值即可。



# 解

### DFS

```go
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
func widthOfBinaryTree(root *TreeNode) int {
    idxMap := make(map[int]int)
    ans := 0
    var dfs func(cur *TreeNode, level int, idx int)

    dfs = func(cur *TreeNode, level int, idx int) {
        if cur == nil {
            return
        }
        dfs(cur.Left, level + 1, idx * 2)
        dfs(cur.Right, level + 1, idx * 2 + 1)

        if _, ok := idxMap[level]; !ok {
            // DFS特性: 优先延左子树往下递归，因此每层遇到的第一个节点为最开始的节点
            idxMap[level] = idx
        }
        ans = max(ans, idx - idxMap[level] + 1)
    }
    dfs(root, 0, 0)
    return ans
}
```



### BFS

```go
type Pair struct {
    node *TreeNode
    idx int
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func widthOfBinaryTree(root *TreeNode) int {
    ans := 0
    q := make([]Pair, 0)
    q = append(q, Pair{root, 0})
    for len(q) != 0 {
        // BFS 层序遍历特性: 每层节点按顺序放入队列，因此直接头尾相减即可
        ans = max(ans, q[len(q)-1].idx - q[0].idx + 1)
        lq := len(q)
        for i := 0; i < lq; i++ {
            top := q[0]
            q = q[1:]
            if top.node.Left != nil {
                q = append(q, Pair{top.node.Left, top.idx * 2})
            }
            if top.node.Right != nil {
                q = append(q, Pair{top.node.Right, top.idx * 2 + 1})
            }
        }
    }
    return ans
}
```

